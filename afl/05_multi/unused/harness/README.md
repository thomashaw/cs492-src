This small exercise is about writing a harness around a bit of code to allow it to be fuzzed with afl.

If you were comfortable with what was happening when fuzzing the `vulnerable` quickstart program, and understand how afl sends data to the target program, you can skip this and move on to the challenges.

Test harness basics
-------------------

The code in `library.c` manipulates some input data and gives an output.
```library.h
// an 'nprintf' implementation - print the first len bytes of data
void lib_echo(char *data, int len);

// optimised multiply - returns x*y
int  lib_mul(int x, int y);
```
How can we fuzz it?

1.  The code needs to be executable - it needs to be compiled into a program.

2.  To allow AFL to work effectively, the code needs to be instrumented - so we have to compile it using one of afl-clang-fast, afl-clang, or afl-gcc.

3.  For the data generated by AFL to actually test the library, we have to write a _harness_ that will take external input and feed it to the library. This can either be from a file specified on the command line, or directly from stdin.

A minimal stdin test harness
----------------------------

To meet point 1 we need a `main()` function that calls the library. Here's an example we'll call `harness.c`:
```
#include "library.h"
#include <string.h>
#include <stdio.h>
void main() {
	char *data = "Some input data";
	lib_echo(data, strlen(data));
	printf("%d", lib_mul(1,2));
}
```

We can compile this minimal program like so:

`AFL_HARDEN=1 ~/afl-2.52b/afl-clang-fast harness.c library.c -o harness -w`

It will call the library code (run `./harness` to test it out), but there's no hook yet to allow the inputs generated by afl to make it to the target function. Try running this program under afl-fuzz: `afl-fuzz -i in -o out ./harness` - you will see that afl gives you a warning that nothing is happening: "(odd, check syntax!)".

So let's make our harness take input from stdin and feed it to the target function. See `man 3 stdin` for an overview if the concept of standard input and output is new to you.

```
#include "library.h"
#include <unistd.h>
#include <string.h>
#include <stdio.h>
int main() {
	// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function
	const int SIZE = 50;

	// make sure buffer is initialized to eliminate variable behaviour that isn't dependent on the input.
	char input[SIZE] = {0};

	ssize_t length;
	length = read(0, input, SIZE);

	lib_echo(input, length);
}
```

After compiling this with the instrumenting compiler, running it under afl-fuzz should give better results - now the inputs it is sending to the program are actually having an impact on the execution flow, and it can discover inputs that lead to different paths.

Arbitrary input formats
-----------------------
Fuzzing `lib_echo` is pretty straightforward - but what about `lib_mul`? It doesn't take a buffer as input, it takes two numbers. To handle this, our harness will simply parse out two integers from the input stream.

```
#include "library.h"
#include <unistd.h>
#include <string.h>
#include <stdio.h>
int main(int argc, char* argv[]) {
	if((argc == 2) && strcmp(argv[1], "echo") == 0) {
		// fixed size buffer based on assumptions about the maximum size that is likely necessary to exercise all aspects of the target function
		const int SIZE = 100;

		// make sure buffer is initialized to eliminate variable behaviour that isn't dependent on the input.
		char input[SIZE] = {0};

		ssize_t length;
		length = read(0, input, SIZE);

		lib_echo(input, length);
	} else if ((argc == 2) && strcmp(argv[1], "mul") == 0) {
		int a,b = 0;
		read(0, &a, 1);
		read(0, &b, 1);
		printf("%d", lib_mul(a,b));
	} else {
		printf("Usage: %s mul|echo\n", argv[0]);
	}
}
```

We don't need to 'tell' afl-fuzz about what this harness in any way - it will work it out, just like it does for any other input format. But note that as we've added some functionality to our harness to specify which library function to fuzz, we now we need to tell afl-fuzz how to launch it:

    afl-fuzz -i in -o out ./harness mul

or

    afl-fuzz -i in -o out ./harness echo


Writing a file-input test harness
---------------------------------
Left as an exercise, as reading from stdin is usually sufficient. The steps are:

1.  Read a filename from argv
2.  Open the specified file and read its contents into a buffer.
3.  Pass that buffer to the target function.

Aside: fuzzing for correctness
------------------------------
Consider how you might use fuzzing to test whether `lib_mul` correctly implements the standard multiply operation. This is covered later on in the course slides.
